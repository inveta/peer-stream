<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        --main-bg-color-dark: #000000;
        --font-color-dark: #ffffff;
        --sidabar-bg-color-dark: #708090;
        --btn-hover-bg-color-dark: #1e1313;
      }

      html {
        font-size: calc(14px + (100vw - 480px) * (3 / 720));

        @media (max-width: 480px) {
          font-size: 14px;
        }

        @media (min-width: 1200px) {
          font-size: 16px;
        }
      }

      html::-webkit-scrollbar {
        display: none;
      }

      body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        background-color: var(--main-bg-color-dark);
      }

      input[type="checkbox"] {
        appearance: none;
        width: 4rem;
        height: 2rem;
        position: relative;
        border-radius: 1rem;
        cursor: pointer;
        background-color: white;
        border: 0.125rem solid #dddddd;
      }

      input[type="checkbox"]:before {
        content: "";
        position: absolute;
        width: 1.6rem;
        height: 1.6rem;
        background: #dddddd;
        left: 0.15rem;
        top: 0.075rem;
        border-radius: 50%;
        transition: left cubic-bezier(0.3, 1.5, 0.7, 1) 0.3s;
      }

      input[type="checkbox"]:checked {
        border-color: #00bfff;
      }

      input[type="checkbox"]:checked:before {
        left: 2rem;
        background: #00bfff;
      }

      #configForm {
        margin: 0 0 0 3rem;
        height: 98%;
        color: var(--font-color-dark);
        font-size: 1rem;
        display: flex;
        flex-wrap: wrap;

        @media screen and (min-width: 768px) {
          margin-left: 11rem;
        }
      }

      input,
      textarea {
        color: var(--font-color-dark);
        background-color: var(--main-bg-color-dark);
        border: 1px solid var(--sidabar-bg-color-dark);
        border-radius: 0.5rem;
      }

      .item {
        margin: 0.5rem 0;
        display: flex;
        flex-direction: column;
        width: 100%;
        position: relative;
      }

      .common-input,
      .auth-input {
        margin: 0.5rem 3%;
        width: 44%;

        @media screen and (min-width: 1200px) {
          margin: 0.5rem 1%;
          width: 48%;
        }
      }

      .common-input input,
      .auth-input input {
        width: auto;
        margin: 0.7rem 0;
        height: 1.6rem;
        font-size: 1.2rem;
      }

      .switch-input {
        align-items: center;
        width: calc(100% / 2);
        display: flex;
        flex-direction: column;

        @media screen and (min-width: 425px) {
          width: calc(100% / 4);
        }

        @media screen and (min-width: 1200px) {
          margin: 0.5rem 0.75%;
          width: 11%;
        }
      }

      .switch-input input {
        margin: 0.5rem 0 0 0;
      }

      #exec-container {
        width: 100%;
      }

      .exec-title {
        align-items: center;
        margin: 0.5rem 3% 0;

        @media screen and (min-width: 1200px) {
          height: 2rem;
          margin: 0.5rem 1% 0;
        }
      }

      #exec-input {
        display: flex;
        flex-wrap: wrap;
      }

      .textarea-container {
        width: 44%;
        margin: 0.5rem 3%;
        display: flex;
        flex-direction: column;

        @media screen and (min-width: 1200px) {
          width: 48%;
          margin: 0.5rem 1%;
        }
      }

      .textarea-container textarea {
        height: 10rem;
        margin: 0.7rem 0;
      }

      .sidebar {
        position: fixed;
        top: 0;
        left: 0;
        height: 100%;
        width: 3rem;
        font-size: 1rem;
        z-index: 4;
        color: #000000;

        @media screen and (min-width: 768px) {
          width: 11rem;
        }
      }

      .sidebarBtn {
        height: 64px;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: var(--sidabar-bg-color-dark);
        text-decoration: none;
        color: black;

        @media screen and (min-width: 768px) {
          padding-left: 1rem;
          justify-content: left;
        }
      }

      .sidebarBtn::before {
        filter: sepia(100%) hue-rotate(180deg) saturate(500%);
        content: attr(data-mini);
      }

      @media screen and (min-width: 768px) {
        .sidebarBtn::before {
          content: attr(data-normal);
        }
      }

      .highlighted {
        background-color: var(--main-bg-color-dark);
        color: var(--font-color-dark);
      }

      .fill {
        background-color: var(--sidabar-bg-color-dark);
        flex: 100%;
        height: 100%;
      }

      :has(+ .highlighted) {
        border-bottom-right-radius: 1rem;
      }

      .highlighted + * {
        border-top-right-radius: 1rem;
      }

      .btn:hover {
        cursor: pointer;
      }

      #runningServers-container {
        display: flex;
        height: 100%;
        margin-left: 3rem;

        @media screen and (min-width: 768px) {
          margin-left: 11rem;
        }
      }

      video {
        overflow: hidden;
        height: calc(100vh - 2rem);
        width: 100%;
        margin: 1rem;
      }

      #stats {
        position: absolute;
        pointer-events: none;
        margin: 1rem;
        text-shadow: var(--btn-color-dark) 0 0 0.3em;
        font-size: 1rem;
        color: var(--font-color-dark);
      }
    </style>
  </head>

  <body>
    <script type="text/javascript" src="./peer-stream.js"></script>

    <aside class="sidebar">
      <a
        class="sidebarBtn btn"
        href="./signal.json"
        target="_blank"
        download="signal.json"
        data-normal="‚¨áÔ∏è ‰∏ãËΩΩ signal.json"
        data-mini="‚¨áÔ∏è"
        aria-label="‰∏ãËΩΩ signal.json"
      ></a>
      <rebootWindow
        class="sidebarBtn btn"
        data-normal="üîÑ ÈáçÂêØÁîµËÑë"
        data-mini="üîÑ"
      ></rebootWindow>
      <shutdownSignal
        class="sidebarBtn btn"
        data-normal="‚ùé ÈÄÄÂá∫ signal.js"
        data-mini="‚ùé"
      >
      </shutdownSignal>
      <a
        class="sidebarBtn btn"
        href="#/updateConfig"
        data-normal="‚öôÔ∏è signal.json"
        data-mini="‚öôÔ∏è"
        aria-label="signal.json"
        name="linkToConfig"
      ></a>
      <a
        class="sidebarBtn btn"
        href=" "
        data-normal="üé• ËßÜÈ¢ëÁõëÊéß"
        data-mini="üé•"
        aria-label="ËßÜÈ¢ëÁõëÊéß"
        name="linkToServer"
      ></a>
      <a
        class="sidebarBtn btn"
        href="https://github.com/inveta/peer-stream"
        target="_blank"
        rel="noopener"
        data-normal="üì¶ Github Ê∫êÁ†Å"
        data-mini="üì¶"
        aria-label="Github Ê∫êÁ†Å"
      ></a>
      <div class="fill"></div>
    </aside>
    <main class="content router-view">router-view</main>

    <script type="text/javascript">
      //Â≠óÁ¨¶‰∏≤ËΩ¨dom
      const str2dom = (obj) => {
        return new DOMParser().parseFromString(obj, "text/html");
      };
      //Â≠óÁ¨¶‰∏≤ËΩ¨Â∏ÉÂ∞î
      const str2Boolean = (obj) => {
        return obj.toLowerCase() === "true" ? true : false;
      };
      const canBeParsed = (str) => {
        try {
          JSON.parse(str);
          return true;
        } catch (error) {
          return false;
        }
      };

      const template = (strings, ...keys) => {
        return (...values) => {
          const dict = values[values.length - 1] || {};
          const result = [strings[0]];
          keys.forEach((key, i) => {
            const value = Number.isInteger(key) ? values[key] : dict[key];
            result.push(value, strings[i + 1]);
          });
          return result.join("");
        };
      };
      const execTemp = template`
        <div class="common-input item exec">
          <span>GPU ${"graphicsAdapter"} ËøõÁ®ã‰∏™Êï∞</span>
          <input name="processNumber" id="${"graphicsAdapter"}" type="number" value="${"GPUNumber"}" placeholder="ËØ∑ËæìÂÖ•ÈúÄË¶ÅÁöÑËøõÁ®ã‰∏™Êï∞"/>
        </div>
      `;
      const updateConfig = `
        <form id="configForm">
          <div class="item auth-input">
            <label for="auth">Áî®Êà∑È™åËØÅ</label>
            <input type="password" id="auth" name="auth" pattern="/^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/" />
          </div>
          <div class="item common-input">
            <label for="PORT">Á´ØÂè£</label>
            <input type="number" id="PORT" name="PORT" required />
          </div>
          <div class="item common-input">
            <label for="preload">È¢ÑÂä†ËΩΩ‰∏™Êï∞</label>
            <input type="number" name="preload" id="preload" required />
          </div>
          <div class="item common-input">
            <label for="exeUeCoolTime">ÂÜ∑Âç¥Êó∂Èó¥ (s) </label>
            <input type="number" name="exeUeCoolTime" id="exeUeCoolTime" required>
          </div>
          <div class="item switch-input">
            <label for="auth">http ËÆ§ËØÅ</label>
            <input type="checkbox" id="http-auth" name="http-auth" />
          </div>
          <div class="item switch-input">
            <label for="one2one">‰∏ÄÂØπ‰∏ÄÊ®°Âºè</label>
            <input type="checkbox" id="one2one" name="one2one" />
          </div>
          <div class="item switch-input">
            <label for="boot">
              <span>ÂºÄÊú∫Ëá™ÂêØÂä®</span>
            </label>
            <input type="checkbox" id="boot" name="boot" />
          </div>
          <div class="item switch-input">
            <label for="UEVersion">
              <span>ÊóßÁâà UE4</span>
            </label>
            <input type="checkbox" id="UEVersion" name="UEVersion" />
          </div>
          <div id="exec-container">
            <div class="exec-title">UE5</div>
            <div id="exec-input">
              <div class="item common-input">
                <label for="GPUFile">UEÂêØÂä®ËøõÁ®ã</label>
                <input type="text" name="GPUFile" id="GPUFile" placeholder="Â°´ÂÖ•GPUÊúçÂä°Âô®‰∏≠ÁöÑÊñá‰ª∂(ÈúÄË¶ÅÂ°´ÂÖ•ÁªùÂØπÂú∞ÂùÄ)" />
              </div>
              <div class="item common-input">
                <label for="pixelStreamingURL">WebSocketÂú∞ÂùÄ</label>
                <input type="text" name="pixelStreamingURL" id="pixelStreamingURL"
                  placeholder="Â°´ÂÖ•ÈìæÊé•signal.jsÁöÑWebSocketÂú∞ÂùÄ" />
              </div>
              <div class="item common-input">
                <label for="resolution">ÂàÜËæ®Áéá</label>
                <input name="resolution" list="resolutionList" id="resolution"
                  placeholder="Â°´ÂÖ•ÊâÄÈúÄÂàÜËæ®Áéá(ËØ∑‰ΩøÁî®Ê†áÂáÜÂàÜËæ®ÁéáÊ†ºÂºèÔºåÂ¶ÇÔºö1920*1080)" />
                <datalist id="resolutionList">
                  <option value="1920*1080"></option>
                  <option value="1600*900"></option>
                  <option value="1366*768"></option>
                  <option value="1280*720"></option>
                  <option value="800*600"></option>
                  <option value="640*480"></option>
                </datalist>
              </div>
              <div class="item common-input">
                <label for="pixelStreamingWebRTCFps">Ê∏≤ÊüìÂ∏ßÁéá</label>
                <input type="number" name="pixelStreamingWebRTCFps" id="pixelStreamingWebRTCFps"
                  placeholder="Â°´ÂÖ•ÊâÄÈúÄÊ∏≤ÊüìÂá∫ÁöÑÂ∏ßÁéá(Â∫î‰∏∫Êï∞Â≠ó)" />
              </div>
              <div class="item common-input">
                <label for="GPUNumber">GPUÊï∞Èáè</label>
                <input type="number" name="GPUNumber" id="GPUNumber"
                  placeholder="ËØ∑Â°´ÂÖ•ÈúÄË¶ÅÁöÑGPUÊï∞Èáè"/>
              </div>
              <div class="item switch-input">
                <label for="unattended">ÂøΩÁï•ÈîôËØØÂºπÁ™ó</label>
                <input type="checkbox" name="unattended" id="unattended" />
              </div>
              <div class="item switch-input">
                <label for="renderOffScreen">ÂêéÂè∞Ê∏≤ÊüìUE</label>
                <input type="checkbox" name="renderOffScreen" id="renderOffScreen" />
              </div>
              <div class="item switch-input">
                <label for="audioMixer">‰º†ËæìÈü≥È¢ë</label>
                <input type="checkbox" name="audioMixer" id="audioMixer" />
              </div>
            </div>
          </div>
          <div class="textarea-container">
            <span>iceServers</span>
            <textarea id="iceServers" name="iceServers"></textarea>
          </div>
          <div class="textarea-container">
            <span>Â§áÊ≥®</span>
            <textarea id="comment" name="comment"></textarea>
          </div>
        </form> 
      `;
      const runningServer = `
        <div id="runningServers-container">
            <video is="peer-stream" id="ws://10.0.42.16:88" audio> </video>

          <!-- WebRTC monitor -->
          <pre id="stats">Not connected</pre>    
        </div>
      `;
      // DOMÊü•ËØ¢ÁºìÂ≠ò
      const $ = (selector) => document.querySelector(selector);
      const $$ = (selector) => document.querySelectorAll(selector);

      const handleRebootWindow = async () => {
        try {
          await fetch("./exec", {
            headers: {
              exec: 'sudo shutdown -r now',
            },
          });
        } catch (error) {
          console.log("rebootWindow failed", error);
        }
      };

      const handleShutdownSignal = async () => {
        try {
          await fetch("./eval", {
            headers: {
              eval: encodeURIComponent('process.exit(0)'),
            },
          });
        } catch (error) {
          console.log("shutdown signal failed", error);
        }
      };

      // $("rebootWindow").addEventListener("click", handleRebootWindow);
      $("shutdownSignal").addEventListener("click", handleShutdownSignal);

      const highlightActiveLink = (hash) => {
        // ÁßªÈô§ÊâÄÊúâÈ´ò‰∫Æ
        $$('[name^="linkTo"]').forEach((element) => {
          element.classList.remove("highlighted");
        });
        // Ê†πÊçÆÂìàÂ∏åÂÄºÈ´ò‰∫ÆÁõ∏Â∫îÁöÑÈìæÊé•
        switch (hash) {
          case "/updateConfig":
            $("[name = linkToConfig]").classList.add("highlighted");
            break;
          default:
            $("[name = linkToServer]").classList.add("highlighted");
        }
      };
      //Ê∏≤ÊüìÈ°µÈù¢‰∏ªÂÜÖÂÆπ
      const renderPageContent = async (pageHash) => {
        const rv = document.querySelector(".router-view");
        switch (pageHash) {
          case "/updateConfig": {
            rv.innerHTML = updateConfig;
            await renderConfigForm();
            $("#auth").addEventListener("focus", () => toggleAuthInfo(event));
            $("#auth").addEventListener("blur", () => toggleAuthInfo(event));
            $("#http-auth").addEventListener("click", () => toggleAuthInput());
            $("#configForm").addEventListener("change", () =>
              submitConfig(event)
            );
            if (typeof ps !== "undefined") window.clearTimeout(ps.timeout);
            break;
          }
          default: {
            rv.innerHTML = runningServer;
            ps.addEventListener("playing", aggregateStats, {
              once: true,
            });
            ps.addEventListener("message", (e) => {});
            ps.addEventListener("suspend", (e) => {});
            ps.addEventListener("playerdisconnected", (e) => {
              console.log("playerdisconnected");
            });
          }
        }
      };

      //ÂºÄÂÖ≥httpÈ™åËØÅ
      const toggleAuthInput = () => {
        const displayAuth = $("#http-auth").checked;
        $(".auth-input").style.display = displayAuth ? "flex" : "none";
        $(".auth-input").querySelector("input").value = "";
      };
      const toggleAuthInfo = (event) => {
        const auth = $("#auth");
        switch (event.type) {
          case "focus":
            auth.type = "text";
            break;
          case "blur":
            auth.type = "password";
            break;
        }
      };
      const parseUE5 = (UE5) => {
        const exec = {
          unattended: false,
          renderOffScreen: false,
          audioMixer: false,
        };

        const params = UE5.split(" ");
        [, exec.GPUFile] = params;

        const paramMapping = {
          "-PixelStreamingURL": "pixelStreamingURL",
          "-GraphicsAdapter": "graphicsAdapter",
          "-ResX": "resX",
          "-ResY": "resY",
          "-PixelStreamingWebRTCFps": "pixelStreamingWebRTCFps",
          "-Unattended": "unattended",
          "-RenderOffScreen": "renderOffScreen",
          "-AudioMixer": "audioMixer",
        };

        params.forEach((param) => {
          if (param.startsWith("-")) {
            const [key, value] = param.split("=");
            if (paramMapping[key]) {
              exec[paramMapping[key]] =
                key.startsWith("-Unattended") ||
                key.startsWith("-RenderOffScreen") ||
                key.startsWith("-AudioMixer")
                  ? true
                  : value;
            }
          }
        });

        exec.resolution = `${exec.resX}*${exec.resY}`;
        delete exec.resX;
        delete exec.resY;

        return exec;
      };

      const processData = (data) => {
        const params = [
          "PORT",
          "auth",
          "one2one",
          "UE5",
          "preload",
          "exeUeCoolTime",
          "UEVersion",
          "iceServers",
          "boot",
          "comment",
        ];
        const handlers = {
          UE5: (value) => {
            const shareInfo = ({
              GPUFile,
              pixelStreamingURL,
              graphicsAdapter,
              resolution,
              pixelStreamingWebRTCFps,
              unattended,
              renderOffScreen,
              audioMixer,
            } = parseUE5(value[0]));
            shareInfo.graphicsAdapter = new Map();
            value.forEach((exec) => {
              const { graphicsAdapter } = parseUE5(exec);
              shareInfo.graphicsAdapter.set(
                graphicsAdapter,
                (shareInfo.graphicsAdapter.get(graphicsAdapter) || 0) + 1
              );
            });
            shareInfo.GPUNumber = shareInfo.graphicsAdapter.size;
            for (const item in shareInfo) {
              if (item === "graphicsAdapter") {
                for (const gpuInfo of shareInfo.graphicsAdapter) {
                  const temp = execTemp({
                    graphicsAdapter: gpuInfo[0],
                    GPUNumber: gpuInfo[1],
                  });
                  const exec = str2dom(temp).querySelector(".exec");

                  $("#exec-input").appendChild(exec);
                }
              } else {
                const input = $(`[name = ${item}]`);
                if (input.type === "checkbox") {
                  input.checked = shareInfo[`${item}`];
                } else {
                  input.value = shareInfo[`${item}`];
                }
              }
            }
          },

          iceServers: (value) => {
            $("[name=iceServers]").value = JSON.stringify(value, null, "\t");
          },
          auth: (value) => {
            if (typeof value === "string") {
              $("#auth").value = value;
              $("#http-auth").checked = true;
            } else if (typeof value === "boolean") {
              $("#http-auth").checked = value;
              toggleAuthInput();
            }
          },
          UEVersion: (value) => {
            document.querySelector("[name=UEVersion]").checked = value === 4.27;
          },
        };

        for (const key in data) {
          if (!params.includes(key)) continue;

          if (handlers[key]) {
            handlers[key](data[key]);
          } else {
            const item = document.querySelector(`[name="${key}"]`);
            if (item) {
              if (item.type === "checkbox") {
                item.checked = data[key];
              } else {
                item.value = data[key];
              }
            }
          }
        }
      };

      const renderConfigForm = () => {
        return fetch("./signal.json")
          .then((res) => {
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }
            return res.json();
          })
          .then((data) => {
            processData(data);
          })
          .catch((error) => {
            alert("Ëé∑Âèñsignal.jsonÂ§±Ë¥•ÔºÅÔºÅÔºÅ");
            console.log("fetch signal.json failed ", error);
          });
      };

      //Â§ÑÁêÜËé∑ÂèñÂà∞ÁöÑÈÖçÁΩÆÂπ∂Êèê‰∫§
      const submitConfig = async (event) => {
        try {
          const config = {};
          const element = event.target;
          console.log(element.parentNode.parentNode);
          const key = element.id;
          let value =
            element.type === "checkbox" ? element.checked : element.value;
          let PORT_new = null;

          if (key === "GPUNumber") {
            var execElements = $$(".exec");
            var gpuNumber = parseInt($("#GPUNumber").value, 10);

            if (execElements.length < gpuNumber) {
              for (let i = execElements.length; i < gpuNumber; i++) {
                const temp = execTemp({
                  graphicsAdapter: i,
                  GPUNumber: 0,
                });
                const exec = str2dom(temp).querySelector(".exec");

                $("#exec-input").appendChild(exec);
              }
            } else if (execElements.length > gpuNumber) {
              var excess = execElements.length - gpuNumber;

              for (let i = 0; i < excess; i++) {
                execElements[execElements.length - 1 - i].remove();
              }
            }
            return;
          }
          if (key === "http-auth" && value === true) return;
          if (key === "iceServers" && !canBeParsed(value)) {
            alert("iceServersÊ†ºÂºèÊúâËØØÔºÅ");
            renderPageContent(window.location.hash.slice(1));
            return;
          }
          if ($("#exec-input").contains(element)) {
            config["UE5"] = [];
            const selector = (name) => $(`[name=${name}]`);

            const GPUFile = selector("GPUFile").value;
            const pixelStreamingURL = selector("pixelStreamingURL").value;
            const [resX, resY] = selector("resolution").value.split("*");
            const pixelStreamingWebRTCFps = selector(
              "pixelStreamingWebRTCFps"
            ).value;

            const unattended = selector("unattended").checked
              ? "-Unattended"
              : "";
            const renderOffScreen = selector("renderOffScreen").checked
              ? "-RenderOffScreen"
              : "";
            const audioMixer = selector("audioMixer").checked
              ? "-AudioMixer"
              : "";

            $$("[name = processNumber]").forEach((exec) => {
              const processNumber = exec.value;
              for (let i = 0; i < processNumber; i++) {
                config["UE5"].push(
                  `start ${GPUFile} ${unattended} ${renderOffScreen} ${audioMixer} -PixelStreamingURL=${pixelStreamingURL} -GraphicsAdapter=${exec.id} -ForceRes -ResX=${resX} -ResY=${resY} -PixelStreamingWebRTCFps=${pixelStreamingWebRTCFps}`
                );
              }
            });
          } else {
            switch (element.type) {
              case "number":
                config[key] = parseFloat(value);
                if (key === "PORT" && value !== window.location.port)
                  PORT_new = value;
                break;
              case "checkbox":
                config[key === "http-auth" ? "auth" : key] =
                  key === "UEVersion" ? (value ? 4.27 : 5) : value;
                break;
              default:
                if (element.name === "auth") {
                  const authRule = /^[a-zA-Z0-9]+:[a-zA-Z0-9]+$/;
                  if (!authRule.test(value)) {
                    alert(
                      "ËØ∑ËæìÂÖ•Ê≠£Á°ÆÁöÑÁî®Êà∑ÂêçÂíåÂØÜÁ†ÅÊ†ºÂºèÔºå‰æãÂ¶ÇÔºöusername:password„ÄÇ"
                    );
                    renderPageContent(window.location.hash.slice(1));
                    return;
                  }
                }
                config[key] =
                  element.name === "iceServers" ? JSON.parse(value) : value;
            }
          }

          await fetch("./signal", {
            method: "POST",
            headers: {
              "Content-type": "application/json",
              signal: encodeURIComponent(JSON.stringify(config)),
            },
          }).then((res) => {
            if (res.ok) {
              $("[name = linkToConfig]").setAttribute(
                "data-normal",
                "‚úÖ Êõ¥Êñ∞ÊàêÂäü"
              );
              $("[name = linkToConfig]").setAttribute("data-mini", "‚úÖ");
              $("[name = linkToConfig]").animate(
                [{ opacity: 0 }, { opacity: 1 }],
                {
                  duration: 200,
                  iterations: 3,
                  easing: "steps(2, jump-none)",
                }
              );
              setTimeout(() => {
                $("[name = linkToConfig]").setAttribute(
                  "data-normal",
                  "‚öôÔ∏è signal.json"
                );
                $("[name = linkToConfig]").setAttribute("data-mini", "‚öôÔ∏è");
              }, 1000);

              if (PORT_new) {
                const url = new URL(window.location);
                url.port = PORT_new;
                window.location.replace(url);
              }
            } else {
              return res.text().then(text => {
                throw new Error(text);
              });
              renderPageContent(window.location.hash.slice(1));
            }
          });
        } catch (error) {
          alert(`‚ùå Êõ¥Êñ∞Â§±Ë¥• ${error}`);
          console.log("updateConfig failed", error);
        }
      };

      const aggregateStats = async () => {
        const statsReport = await ps.pc.getStats(null);
        stats.innerText = "";

        // most < 27
        if (ps.VideoEncoderQP < 27) {
          stats.style.color = "lime";
        } else if (ps.VideoEncoderQP < 36) {
          stats.style.color = "orange";
          stats.innerText += `\n Spotty Network !`;
        } else {
          stats.style.color = "red";
          stats.innerText += `\n Bad Network !!`;
        }

        stats.innerText += `\n Video Quantization Parameter: ${ps.VideoEncoderQP}`;
        statsReport.forEach((stat) => {
          switch (stat.type) {
            case "data-channel": {
              stats.innerText += `\n ‚úâ Data Channel ‚Üë‚Üë ${stat.bytesSent.toLocaleString()} B`;
              stats.innerText += `\n ‚úâ Data Channel ‚Üì‚Üì ${stat.bytesReceived.toLocaleString()} B`;
              break;
            }
            case "inbound-rtp": {
              if (stat.mediaType === "video")
                stats.innerText += [
                  ``,
                  `	Size: ${stat.frameWidth} x ${stat.frameHeight}`,
                  `	Frames Decoded: ${stat.framesDecoded.toLocaleString()}`,
                  `	Packets Lost: ${stat.packetsLost.toLocaleString()}`,
                  `	FPS: ${stat.framesPerSecond} Hz`,
                  `	Frames Dropped: ${stat.framesDropped}`,
                  `	Video ‚Üì‚Üì ${stat.bytesReceived.toLocaleString()} B`,
                ].join("\n");
              else if (stat.mediaType === "audio")
                stats.innerText += `\n ‚ô¨ Audio ‚Üì‚Üì ${stat.bytesReceived.toLocaleString()} B`;
              break;
            }
            case "candidate-pair": {
              if (stat.state === "succeeded")
                stats.innerText += `\n Latency(RTT): ${stat.currentRoundTripTime} s`;
              break;
            }
            case "remote-candidate": {
              stats.innerText +=
                `\n ` + stat.protocol + ":// " + stat.ip + ": " + stat.port;
              break;
            }
            case "transport": {
              const bitrate = ~~(
                ((stat.bytesReceived - this.bytesReceived) /
                  (stat.timestamp - this.timestamp)) *
                (1000 * 8)
              );

              stats.innerText += `\n ‚áå Bitrate: ${bitrate.toLocaleString()} bps`;

              this.bytesReceived = stat.bytesReceived;
              this.timestamp = stat.timestamp;
              break;
            }
            default: {
            }
          }
        });

        stats.innerText += `\n ‚è≤ Current Time: ${ps.currentTime} s`;

        ps.timeout = setTimeout(aggregateStats, 1000);
      };

      const navigateBasedOnHash = () => {
        const pageHash = window.location.hash.slice(1);
        renderPageContent(pageHash);
        highlightActiveLink(pageHash);
      };
      // // È°µÈù¢Âä†ËΩΩÂíåÂèòÂåñ‰∫ã‰ª∂
      window.onload = () => {
        navigateBasedOnHash();
      };
      window.onhashchange = () => {
        navigateBasedOnHash();
      };
    </script>
  </body>
</html>
